OBS: Em algumas linguagens de programação, os dicionários Python são conhecidos por mapas.

Dicionários são coleções do tipo chave/valor de maneira explicita. 

Dicionários são representados por `{}`

```python
print(type({}))

#dictionary
```

-  Chave e valor são separados por dois pontos `'br': 'Brasil'`
-  Tanto chave quanto valor podem ser de qualquer tipo de dado
-  Podemos misturar tipos de dados
- 
## Criação de dicionários
###  Foma 1  (Mais Comum)
```python

paises = { 'br': 'Brasil', 'eua': 'Estados Unidos'}

print(paises)
```

### Forma 2 (Menos Comum)

```python
paises2 = dict( br= 'Brasil', eua = 'Estados Unidos', py = 'Paraguay')
```

## Acessando elementos

### Forma 1 - Acessando via chave, de mesma forma que lista/tupla

```python
paises = { 'br': 'Brasil', 'eua': 'Estados Unidos'}
print(paises['br'])
print(paises['eua'])

```

Invés de utilizar índice, utilizamos a chave. 

OBS: Caso tentamos fazer um acesso utilizando uma a chave que não existe, teremos o erro KeyError.

## Forma 2 - Acessando via get - Recomendado

```python
print(paises.get('br'))

print(paises.get('ru'))

print(paises.get('eua'))
```

Com o get, se alguma  chave não existir, ela retorna None, e não um erro.

##### Podemos colocar um valor padrão nesse método get:

```python
print(paises.get('ru', 'Não encontrado))
```


### Forma 3 

Podemos verificar se determinada chave se encontra em um dicionário

```python
paises = { 'br': 'Brasil', 'eua': 'Estados Unidos', 'py': 'Paraguay'}

print('br' in paises) # output: True
print('ru' in paises) # output: False
print('Brasil' in paises)  # output: False
```

- Apenas verifica chaves, não funciona com valores.

## Podemos utilizar qualquer tipo de dado

Podemos utilizar qualquer tipo de dado (int,float,string,boolean), inclusive lista, tupla, dicionários, como também chave de dicionários.

```python
localidades = {

#tupla com float #string
(35.123, 39.123): 'Escritório em Tokyo',
(40.123, 74.123): 'Escritório em NY',
(37.123, 122.123): 'Escritório em São Paulo'
}
print(localidades)
```

OBS: Tuplas são bastante interessantes de serem utilizadas como chave de dicionários, pois as mesmas são imutáveis.

## Adicionar elementos em um dicionário

```python

receita = { 'jan': 100, 'fev': 120, 'mar': 300}

# forma 1 - mais comum
receita['abr'] = 350
print(receita)

#Forma 2
novo_dado = {'mai': 500}
receita.update(novo_dado) # receita.update({'mai': 500})
print(receita)

```

## Podemos também atualizar dados de um dicionário

```python

receita['mai'] = 1000
receita.update({'jan': 20 })
print(receita)
```

CONCLUSÃO 1: A forma de adicionar novos elementos ou atualizar dados em um dicionário é a mesma
CONCLUSÃO 2: Em dicionários, NÃO podemos ter chaves repetidas

## Remover dados de um dicionário

#### Forma 1 (Mais comum): 

Precisamos sempre informar a chave, e caso não encontre o elemento, um KeyError é retornado

```python
receita = {'jan': 20, 'fev': 120, 'mar': 300, 'abr': 350, 'mai': 1000}

receita.pop('mar')
```

OBS: Ao removermos um objeto, o valor deste objeto é sempre retornado
#### Forma 2: 

```python
del receita['fev']
```

- Se a chave não existir será gerado um KeyError
- Neste caso o valor removido não é retornado.

## Métodos

##### Shallow copy e Deep copy funcionam em dicionários


### Fromkeys

Método que recebe dois parâmetros: um iterável e um valor

Ele vai gerar para cada valor do iterável uma chave e irá atribuir a esta chave o valor informado.

```python
outro = {}.fromkeys('a', 'b')
print(outro)
# {'a': 'b'}

usuario = {}.fromkeys(['nome', 'pontos', 'email', 'numero'], 'desconhecido')
print(usuario)
# {'nome': 'desconhecido', 'pontos': 'desconhecido', 'email': 'desconhecido', 'numero': 'desconhecido'}

```

Como uma string é iterável, isso acontece se utilizar string como o primeiro parâmetro:

```python
veja = {}.fromkeys('teste', 'valor')
print(veja)

# {'t': 'valor', 'e': 'valor', 's': 'valor'}
```

A palavra teste se repete também,  porque não pode ter duas keys iguais.

Podemos usar range também

```python

ex = {}.fromkeys(range(1,5), 'null')
print(ex)
# {1: 'null', 2: 'null', 3: 'null', 4: 'null'}
```

# # Iterando sobre Dicionários


```python
receita = {'jan': 100, 'fev': 250, 'marc': 400}
for chave in receita:
	print(chave)

for chave in receita:
	print(receita[chave])

for chave in receita:
	print(f"{chave}: {receita[chave]}")

```

### Modo pythonico - Mais recomendado

```python
receita = {'jan': 100, 'fev': 250, 'marc': 400}
print(receita.keys())
for chave in receita.keys():
	print(receita[chave])
```

### Acessando valores

```python
receita = {'jan': 100, 'fev': 250, 'marc': 400}
print(receita.values())

for valor in receita.values():
	print(valor)
```

# Desempacotamento de dicionários

  
```python
receita = {'jan': 100, 'fev': 250, 'marc': 400}
print(receita.items())

for chave,valor in receita.items():
	print(f"{chave}: {valor}")
```


### Soma / Max / Min / Tamanho


Soma* / Valor Max* / Valor Min* / tamanho
*Se os valores forem todos inteiros ou reais

```python
receita = {'jan': 100, 'fev': 250, 'marc': 400}
  
print(sum(receita.values()))
print(max(receita.values()))
print(min(receita.values()))
print(len(receita.values()))
```